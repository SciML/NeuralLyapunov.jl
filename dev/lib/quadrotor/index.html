<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quadrotor Models · NeuralLyapunov.jl</title><meta name="title" content="Quadrotor Models · NeuralLyapunov.jl"/><meta property="og:title" content="Quadrotor Models · NeuralLyapunov.jl"/><meta property="twitter:title" content="Quadrotor Models · NeuralLyapunov.jl"/><meta name="description" content="Documentation for NeuralLyapunov.jl."/><meta property="og:description" content="Documentation for NeuralLyapunov.jl."/><meta property="twitter:description" content="Documentation for NeuralLyapunov.jl."/><meta property="og:url" content="https://SciML.github.io/NeuralLyapunov.jl/lib/quadrotor/"/><meta property="twitter:url" content="https://SciML.github.io/NeuralLyapunov.jl/lib/quadrotor/"/><link rel="canonical" href="https://SciML.github.io/NeuralLyapunov.jl/lib/quadrotor/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NeuralLyapunov.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/">Components of a Neural Lyapunov Problem</a></li><li><a class="tocitem" href="../../man/pdesystem/">Solving a Neural Lyapunov Problem</a></li><li><a class="tocitem" href="../../man/minimization/">Lyapunov Minimization Condition</a></li><li><a class="tocitem" href="../../man/decrease/">Lyapunov Decrease Condition</a></li><li><a class="tocitem" href="../../man/structure/">Structuring a Neural Lyapunov function</a></li><li><a class="tocitem" href="../../man/roa/">Training for Region of Attraction Identification</a></li><li><a class="tocitem" href="../../man/policy_search/">Policy Search and Network-Dependent Dynamics</a></li><li><a class="tocitem" href="../../man/local_lyapunov/">Local Lyapunov analysis</a></li></ul></li><li><span class="tocitem">Demonstrations</span><ul><li><a class="tocitem" href="../../demos/damped_SHO/">Damped Simple Harmonic Oscillator</a></li><li><a class="tocitem" href="../../demos/roa_estimation/">Estimating the Region of Attraction</a></li><li><a class="tocitem" href="../../demos/policy_search/">Policy Search on the Driven Inverted Pendulum</a></li><li><a class="tocitem" href="../../demos/benchmarking/">Benchmarking a neural Lyapunov method</a></li></ul></li><li><span class="tocitem">Test Problem Library</span><ul><li><a class="tocitem" href="../">NeuralLyapunovProblemLibrary.jl</a></li><li><a class="tocitem" href="../pendulum/">Pendulum Model</a></li><li><a class="tocitem" href="../double_pendulum/">Double Pendulum Model</a></li><li class="is-active"><a class="tocitem" href>Quadrotor Models</a><ul class="internal"><li><a class="tocitem" href="#Planar-Approximation"><span>Planar Approximation</span></a></li><li><a class="tocitem" href="#3D-Model"><span>3D Model</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Test Problem Library</a></li><li class="is-active"><a href>Quadrotor Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quadrotor Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NeuralLyapunov.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NeuralLyapunov.jl/blob/master/docs/src/lib/quadrotor.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quadrotor-Models"><a class="docs-heading-anchor" href="#Quadrotor-Models">Quadrotor Models</a><a id="Quadrotor-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrotor-Models" title="Permalink"></a></h1><p>Two versions of the quadrotor are provided: a planar approximation (<a href="#NeuralLyapunovProblemLibrary.QuadrotorPlanar"><code>QuadrotorPlanar</code></a>) and a 3D model (<a href="#NeuralLyapunovProblemLibrary.Quadrotor3D"><code>Quadrotor3D</code></a>). Additionally, when also using the Plots.jl package, the convenience plotting functions <a href="#NeuralLyapunovProblemLibrary.plot_quadrotor_planar"><code>plot_quadrotor_planar</code></a> and <a href="#NeuralLyapunovProblemLibrary.plot_quadrotor_3d"><code>plot_quadrotor_3d</code></a> are provided.</p><ul><li><a href="#Planar-Approximation">Planar Approximation</a></li><li class="no-marker"><ul><li><a href="#Copy-Pastable-Code">Copy-Pastable Code</a></li><li><a href="#Plotting-the-Planar-Quadrotor">Plotting the Planar Quadrotor</a></li></ul></li><li><a href="#3D-Model">3D Model</a></li><li class="no-marker"><ul><li><a href="#Copy-Pastable-Code-2">Copy-Pastable Code</a></li><li><a href="#Plotting-the-3D-Quadrotor">Plotting the 3D Quadrotor</a></li><li><a href="#References">References</a></li></ul></li></ul><h2 id="Planar-Approximation"><a class="docs-heading-anchor" href="#Planar-Approximation">Planar Approximation</a><a id="Planar-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Planar-Approximation" title="Permalink"></a></h2><p>The planar quadrotor (<a href="#NeuralLyapunovProblemLibrary.QuadrotorPlanar"><code>QuadrotorPlanar</code></a>, technically a birotor) is a rigid body with two rotors in line with the center of mass.</p><p><img src="../../imgs/quadrotor_planar.gif" alt="Planar quadrotor animation"/></p><article><details class="docstring" open="true"><summary id="NeuralLyapunovProblemLibrary.QuadrotorPlanar"><a class="docstring-binding" href="#NeuralLyapunovProblemLibrary.QuadrotorPlanar"><code>NeuralLyapunovProblemLibrary.QuadrotorPlanar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">QuadrotorPlanar(; name, defaults)</code></pre><p>Create an <code>ODESystem</code> representing a planar approximation of the quadrotor (technically a birotor).</p><p>This birotor is a rigid body with two rotors in line with the center of mass. The location of the center of mass is determined by <code>x</code> and <code>y</code>. Its orientation is determined by <code>θ</code>, measured counter-clockwise from the <span>$x$</span>-axis. The thrust from the right rotor (on the positive <span>$x$</span>-axis when <span>$θ = 0$</span>) is the input <code>u1</code>. The thrust from the other rotor is <code>u2</code>. Note that these thrusts should be nonnegative and if a negative input is provided, the model replaces it with 0.</p><p>The equations governing the planar quadrotor are:</p><p class="math-container">\[\begin{align}
    mẍ &amp;= -(u_1 + u_2)\sin(θ), \\
    mÿ &amp;= (u_1 + u_2)\cos(θ) - mg, \\
    I_{quad} \ddot{θ} &amp;= r (u_1 - u_2).
\end{align}\]</p><p>The name of the <code>ODESystem</code> is <code>name</code>.</p><p><strong>ODESystem Parameters</strong></p><ul><li><code>m</code>: mass of the quadrotor.</li><li><code>I_quad</code>: moment of inertia of the quadrotor around its center of mass.</li><li><code>g</code>: gravitational acceleration in the direction of the negative <span>$y$</span>-axis (defaults to 9.81).</li><li><code>r</code>: distance from center of mass to each rotor.</li></ul><p>Users may optionally provide default values of the parameters through <code>defaults</code>: a vector of the default values for <code>[m, I_quad, g, r]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NeuralLyapunov.jl/blob/bf4cc10b332e9574ad3ffcf4aadf39a6bb635cea/lib/NeuralLyapunovProblemLibrary/src/quadrotor.jl#L2-L37">source</a></section></details></article><h3 id="Copy-Pastable-Code"><a class="docs-heading-anchor" href="#Copy-Pastable-Code">Copy-Pastable Code</a><a id="Copy-Pastable-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-Pastable-Code" title="Permalink"></a></h3><pre><code class="language-julia hljs">using ModelingToolkit
using NeuralLyapunovProblemLibrary
using OrdinaryDiffEq
using Plots
using LinearAlgebra
using ControlSystemsBase: lqr, Continuous

@named quadrotor_planar = QuadrotorPlanar()

function π_lqr(p; x_eq = zeros(6), Q = I(6), R = I(2))
    m, I_quad, g, r = p

    # Assumes linearization around a fixed point
    # x_eq = (x*, y*, 0, 0, 0, 0), u_eq = (mg / 2, mg / 2)
    A_lin = zeros(6, 6)
    A_lin[1:3,4:6] .= I(3)
    A_lin[4,3] = -g

    B_lin = zeros(6, 2)
    B_lin[5,:] .= 1 / m
    B_lin[6,:] .= r / I_quad, -r / I_quad

    K = lqr(Continuous, A_lin, B_lin, Q, R)

    T0 = m * g / 2
    return (x) -&gt; -K * (x - x_eq) + [T0, T0]
end

t, = independent_variables(quadrotor_planar)
Dt = Differential(t)

params = [quadrotor_planar.m, quadrotor_planar.I_quad, quadrotor_planar.g, quadrotor_planar.r]
q = [quadrotor_planar.x, quadrotor_planar.y, quadrotor_planar.θ]
u = [quadrotor_planar.u1, quadrotor_planar.u2]
x = vcat(q, Dt.(q))

# Assume rotors are negligible mass when calculating the moment of inertia
m, r = ones(2)
g = 1.0
I_quad = m * r^2 / 12
p = [m, I_quad, g, r]

# Create controller system and combine with quadrotor_planar, then simplify
@named lqr_controller = ODESystem(
    u .~ π_lqr(p)(x),
    t,
    vcat(x, u),
    params
)
@named quadrotor_planar_lqr = compose(lqr_controller, quadrotor_planar)
quadrotor_planar_lqr = structural_simplify(quadrotor_planar_lqr)

# Random initialization
# structural_simplify sometimes rearranges variables, so we use a Dict to provide the
# initialization and parameters when constructing the ODEProblem
x0 = Dict(x .=&gt; 2 * rand(6) .- 1)
p = Dict(params .=&gt; [m, I_quad, g, r])
τ = sqrt(r / g)

prob = ODEProblem(quadrotor_planar_lqr, x0, 15τ, p)
sol = solve(prob, Tsit5())

gif(
    plot_quadrotor_planar(
        sol,
        [m, I_quad, g, r];
        x_symbol=q[1],
        y_symbol=q[2],
        θ_symbol=q[3],
        u1_symbol=u[1],
        u2_symbol=u[2]
    );
    fps = 50
)</code></pre><img src="811db3d8.gif" alt="Example block output"/><h3 id="Plotting-the-Planar-Quadrotor"><a class="docs-heading-anchor" href="#Plotting-the-Planar-Quadrotor">Plotting the Planar Quadrotor</a><a id="Plotting-the-Planar-Quadrotor-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-the-Planar-Quadrotor" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NeuralLyapunovProblemLibrary.plot_quadrotor_planar"><a class="docstring-binding" href="#NeuralLyapunovProblemLibrary.plot_quadrotor_planar"><code>NeuralLyapunovProblemLibrary.plot_quadrotor_planar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_quadrotor_planar(x, y, θ, [u1, u2,] p, t; title)
plot_quadrotor_planar(sol, p; title, N, x_symbol, y_symbol, θ_symbol)</code></pre><p>Plot the planar quadrotor&#39;s trajectory.</p><p>When thrusts are supplied, the arrows scale with thrust, otherwise the arrows are of constant length.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The x-coordinate of the quadrotor at each time step.</li><li><code>y</code>: The y-coordinate of the quadrotor at each time step.</li><li><code>θ</code>: The angle of the quadrotor at each time step.</li><li><code>u1</code>: The thrust of the first rotor at each time step.</li><li><code>u2</code>: The thrust of the second rotor at each time step.</li><li><code>t</code>: The time steps.</li><li><code>sol</code>: The solution to the ODE problem.</li><li><code>p</code>: The parameters of the quadrotor.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>title</code>: The title of the plot; defaults to no title (i.e., <code>title=&quot;&quot;</code>).</li><li><code>N</code>: The number of points to plot; when using <code>x</code>, <code>y</code>, <code>θ</code>, and <code>t</code>, uses <code>length(t)</code>; defaults to 500 when using <code>sol</code>.</li><li><code>x_symbol</code>: The symbol of the x-coordinate in <code>sol</code>; defaults to <code>:x</code>.</li><li><code>y_symbol</code>: The symbol of the y-coordinate in <code>sol</code>; defaults to <code>:y</code>.</li><li><code>θ_symbol</code>: The symbol of the angle in <code>sol</code>; defaults to <code>:θ</code>.</li><li><code>u1_symbol</code>: The symbol of the thrust of the first rotor in <code>sol</code>; defaults to <code>:u1</code>.</li><li><code>u2_symbol</code>: The symbol of the thrust of the second rotor in <code>sol</code>; defaults to <code>:u2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NeuralLyapunov.jl/blob/bf4cc10b332e9574ad3ffcf4aadf39a6bb635cea/lib/NeuralLyapunovProblemLibrary/src/quadrotor.jl#L181-L209">source</a></section></details></article><h2 id="3D-Model"><a class="docs-heading-anchor" href="#3D-Model">3D Model</a><a id="3D-Model-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Model" title="Permalink"></a></h2><p>A full 3D model from (<a href="#quadrotor">Mellinger and Kumar, 2011</a>) is provided via <a href="#NeuralLyapunovProblemLibrary.Quadrotor3D"><code>Quadrotor3D</code></a>.</p><p><img src="../../imgs/quadrotor_3d.gif" alt="3D quadrotor animation"/></p><article><details class="docstring" open="true"><summary id="NeuralLyapunovProblemLibrary.Quadrotor3D"><a class="docstring-binding" href="#NeuralLyapunovProblemLibrary.Quadrotor3D"><code>NeuralLyapunovProblemLibrary.Quadrotor3D</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Quadrotor3D(; name, defaults)</code></pre><p>Create an <code>ODESystem</code> representing a quadrotor in 3D space.</p><p>The quadrotor is a rigid body in an X-shape (90°-angles between the rotors). The equations governing the quadrotor can be found in (<a href="#quadrotor">Mellinger and Kumar, 2011</a>).</p><p><strong>ODESystem State Variables</strong></p><ul><li><code>x</code>: <span>$x$</span>-position (world frame).</li><li><code>y</code>: <span>$y$</span>-position (world frame).</li><li><code>z</code>: <span>$z$</span>-position (world frame).</li><li><code>φ</code>: roll around body <span>$x$</span>-axis (Z-X-Y Euler angles).</li><li><code>θ</code>: pitch around body <span>$y$</span>-axis (Z-X-Y Euler angles).</li><li><code>ψ</code>: yaw around body <span>$z$</span>-axis (Z-X-Y Euler angles).</li><li><code>vx</code>: <span>$x$</span>-velocity (world frame).</li><li><code>vy</code>: <span>$y$</span>-velocity (world frame).</li><li><code>vz</code>: <span>$z$</span>-velocity (world frame).</li><li><code>ωφ</code>: roll angular velocity (world frame).</li><li><code>ωθ</code>: pitch angular velocity (world frame).</li><li><code>ωψ</code>: yaw angular velocity (world frame).</li></ul><p><strong>ODESystem Input Variables</strong></p><ul><li><code>T</code>: thrust (should be nonnegative).</li><li><code>τφ</code>: roll torque.</li><li><code>τθ</code>: pitch torque.</li><li><code>τψ</code>: yaw torque.</li></ul><p>Not only should the aggregate thrust be nonnegative, but the torques should have been generated from nonnegative individual rotor thrusts. The model calculates individual rotor thrusts and replaces any negative values with 0.</p><p><strong>ODESystem Parameters</strong></p><ul><li><code>m</code>: mass of the quadrotor.</li><li><code>g</code>: gravitational acceleration in the direction of the negative <span>$z$</span>-axis (defaults to 9.81).</li><li><code>Ixx</code>,<code>Ixy</code>,<code>Ixz</code>,<code>Iyy</code>,<code>Iyz</code>,<code>Izz</code>: components of the moment of inertia matrix of the quadrotor around its center of mass:<p class="math-container">\[I = \begin{pmatrix}
        I_{xx} &amp; I_{xy} &amp; I_{xz} \\
        I_{xy} &amp; I_{yy} &amp; I_{yz} \\
        I_{xz} &amp; I_{yz} &amp; I_{zz}
    \end{pmatrix}.\]</p></li></ul><p>Users may optionally provide default values of the parameters through <code>defaults</code>: a vector of the default values for <code>[m, g, Ixx, Ixy, Ixz, Iyy, Iyz, Izz]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NeuralLyapunov.jl/blob/bf4cc10b332e9574ad3ffcf4aadf39a6bb635cea/lib/NeuralLyapunovProblemLibrary/src/quadrotor.jl#L66-L114">source</a></section></details></article><h3 id="Copy-Pastable-Code-2"><a class="docs-heading-anchor" href="#Copy-Pastable-Code-2">Copy-Pastable Code</a><a class="docs-heading-anchor-permalink" href="#Copy-Pastable-Code-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">using ModelingToolkit
import ModelingToolkit: inputs
using NeuralLyapunovProblemLibrary
using OrdinaryDiffEq
using Plots
using LinearAlgebra
using ControlSystemsBase: lqr, Continuous

# Define LQR controller
function π_lqr(p; x_eq = zeros(12), u_eq = [p[1]*p[2], 0, 0, 0], Q = I(12), R = I(4))
    @named quadrotor_3d = Quadrotor3D()

    # Use equilibrium as linearization point
    u = inputs(quadrotor_3d)
    x = setdiff(unknowns(quadrotor_3d), u)
    params = parameters(quadrotor_3d)
    op = Dict(vcat(x .=&gt; x_eq, u .=&gt; u_eq, params .=&gt; p))

    # Linearize with ModelingToolkit
    mats, sys = linearize(quadrotor_3d, u, x; op)

    # Sometimes linearization will reorder the variables, but we can undo that with
    # permutation matrices Px : x_new = Px * x and Pu : u_new = Pu * u
    x_new = unknowns(sys)
    u_new = inputs(sys)

    Px = (x_new .- x&#39;) .=== 0
    Pu = (u_new .- u&#39;) .=== 0

    A_lin = Px&#39; * mats[:A] * Px
    B_lin = Px&#39; * mats[:B] * Pu

    K = lqr(Continuous, A_lin, B_lin, Q, R)
    return (x) -&gt; -K * (x - x_eq) + u_eq
end

@named quadrotor_3d = Quadrotor3D()

# Set up variable symbols
t, = independent_variables(quadrotor_3d)
Dt = Differential(t)

x = [
    quadrotor_3d.x,
    quadrotor_3d.y,
    quadrotor_3d.z,
    quadrotor_3d.φ,
    quadrotor_3d.θ,
    quadrotor_3d.ψ,
    quadrotor_3d.vx,
    quadrotor_3d.vy,
    quadrotor_3d.vz,
    quadrotor_3d.ωφ,
    quadrotor_3d.ωθ,
    quadrotor_3d.ωψ
]

u = [
    quadrotor_3d.T,
    quadrotor_3d.τφ,
    quadrotor_3d.τθ,
    quadrotor_3d.τψ
]

params = [
    quadrotor_3d.m,
    quadrotor_3d.g,
    quadrotor_3d.Ixx,
    quadrotor_3d.Ixy,
    quadrotor_3d.Ixz,
    quadrotor_3d.Iyy,
    quadrotor_3d.Iyz,
    quadrotor_3d.Izz
]

# Assume rotors are negligible mass when calculating the moment of inertia
m, L = ones(2)
g = 1.0
Ixx = Iyy = m * L^2 / 6
Izz = m * L^2 / 3
Ixy = Ixz = Iyz = 0.0
p = [m, g, Ixx, Ixy, Ixz, Iyy, Iyz, Izz]

# Create controller system and combine with quadrotor_3d, then simplify
@named lqr_controller = ODESystem(
    u .~ π_lqr(p)(x),
    t,
    vcat(x, u),
    params
)

@named quadrotor_3d_lqr = compose(lqr_controller, quadrotor_3d)
quadrotor_3d_lqr = structural_simplify(quadrotor_3d_lqr)

# Random initialization
# structural_simplify sometimes rearranges variables, so we use a Dict to provide the
# initialization and parameters when constructing the ODEProblemp = Dict(params .=&gt; p)
δ = 0.5
x0 = Dict(x .=&gt; δ .* (2 .* rand(12) .- 1))
τ = sqrt(L / g)
p = Dict(params .=&gt; [m, g, Ixx, Ixy, Ixz, Iyy, Iyz, Izz])

prob = ODEProblem(quadrotor_3d_lqr, x0, 15τ, p)
sol = solve(prob, Tsit5())

gif(
    plot_quadrotor_3d(
        sol,
        [m, g, Ixx, Ixy, Ixz, Iyy, Iyz, Izz];
        x_symbol=x[1],
        y_symbol=x[2],
        z_symbol=x[3],
        φ_symbol=x[4],
        θ_symbol=x[5],
        ψ_symbol=x[6],
        T_symbol=u[1],
        τφ_symbol=u[2],
        τθ_symbol=u[3],
        τψ_symbol=u[4]
    );
    fps=50
)</code></pre><img src="28270745.gif" alt="Example block output"/><h3 id="Plotting-the-3D-Quadrotor"><a class="docs-heading-anchor" href="#Plotting-the-3D-Quadrotor">Plotting the 3D Quadrotor</a><a id="Plotting-the-3D-Quadrotor-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-the-3D-Quadrotor" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NeuralLyapunovProblemLibrary.plot_quadrotor_3d"><a class="docstring-binding" href="#NeuralLyapunovProblemLibrary.plot_quadrotor_3d"><code>NeuralLyapunovProblemLibrary.plot_quadrotor_3d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_quadrotor_3d(x, y, z, φ, θ, ψ, [T, τφ, τθ, τψ,] p, t; title)
plot_quadrotor_3d(sol, p; title, N, x_symbol, y_symbol, z_symbol, φ_symbol, θ_symbol, ψ_symbol, T_symbol, τφ_symbol, τθ_symbol, τψ_symbol)</code></pre><p>Plot the 3D quadrotor&#39;s trajectory.</p><p>When thrusts are supplied, the arrows scale with thrust, otherwise the arrows are of constant length.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The x-coordinate of the quadrotor at each time step.</li><li><code>y</code>: The y-coordinate of the quadrotor at each time step.</li><li><code>z</code>: The z-coordinate of the quadrotor at each time step.</li><li><code>φ</code>: The roll of the quadrotor at each time step.</li><li><code>θ</code>: The pitch of the quadrotor at each time step.</li><li><code>ψ</code>: The yaw of the quadrotor at each time step.</li><li><code>T</code>: The thrust of the quadrotor at each time step.</li><li><code>τφ</code>: The roll torque of the quadrotor at each time step.</li><li><code>τθ</code>: The pitch torque of the quadrotor at each time step.</li><li><code>τψ</code>: The yaw torque of the quadrotor at each time step.</li><li><code>t</code>: The time steps.</li><li><code>sol</code>: The solution to the ODE problem.</li><li><code>p</code>: The parameters of the quadrotor.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>title</code>: The title of the plot; defaults to no title (i.e., <code>title=&quot;&quot;</code>).</li><li><code>N</code>: The number of points to plot; when using <code>x</code>, <code>y</code>, <code>z</code>, etc., uses <code>length(t)</code>; defaults to 500 when using <code>sol</code>.</li><li><code>x_symbol</code>: The symbol of the x-coordinate in <code>sol</code>; defaults to <code>:x</code>.</li><li><code>y_symbol</code>: The symbol of the y-coordinate in <code>sol</code>; defaults to <code>:y</code>.</li><li><code>z_symbol</code>: The symbol of the z-coordinate in <code>sol</code>; defaults to <code>:z</code>.</li><li><code>φ_symbol</code>: The symbol of the roll in <code>sol</code>; defaults to <code>:φ</code>.</li><li><code>θ_symbol</code>: The symbol of the pitch in <code>sol</code>; defaults to <code>:θ</code>.</li><li><code>ψ_symbol</code>: The symbol of the yaw in <code>sol</code>; defaults to <code>:ψ</code>.</li><li><code>T_symbol</code>: The symbol of the thrust in <code>sol</code>; defaults to <code>:T</code>.</li><li><code>τφ_symbol</code>: The symbol of the roll torque in <code>sol</code>; defaults to <code>:τφ</code>.</li><li><code>τθ_symbol</code>: The symbol of the pitch torque in <code>sol</code>; defaults to <code>:τθ</code>.</li><li><code>τψ_symbol</code>: The symbol of the yaw torque in <code>sol</code>; defaults to <code>:τψ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NeuralLyapunov.jl/blob/bf4cc10b332e9574ad3ffcf4aadf39a6bb635cea/lib/NeuralLyapunovProblemLibrary/src/quadrotor.jl#L212-L250">source</a></section></details></article><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><div class="citation canonical"><ul><li><div id="quadrotor">Mellinger, D. and Kumar, V. (2011). <a href="https://doi.org/10.1109/ICRA.2011.5980409"><em>Minimum snap trajectory generation and control for quadrotors</em></a>. In: <em>2011 IEEE International Conference on Robotics and Automation</em>; pp. 2520–2525.</div></li></ul></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../double_pendulum/">« Double Pendulum Model</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 12 December 2025 16:56">Friday 12 December 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
